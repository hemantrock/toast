if (Object.isUndefined(Effect)) { throw ("dragdrop.js requires including script.aculo.us' effects.js library") } var Droppables = { drops: [], remove: function (B) { this.drops = this.drops.reject(function (A) { return A.element == $(B) }) }, add: function (F) { F = $(F); var D = Object.extend({ greedy: true, hoverclass: null, tree: false }, arguments[1] || {}); if (D.containment) { D._containers = []; var E = D.containment; if (Object.isArray(E)) { E.each(function (A) { D._containers.push($(A)) }) } else { D._containers.push($(E)) } } if (D.accept) { D.accept = [D.accept].flatten() } Element.makePositioned(F); D.element = F; this.drops.push(D) }, findDeepestChild: function (B) { deepest = B[0]; for (i = 1; i < B.length; ++i) { if (Element.isParent(B[i].element, deepest.element)) { deepest = B[i] } } return deepest }, isContained: function (F, D) { var E; if (D.tree) { E = F.treeNode } else { E = F.parentNode } return D._containers.detect(function (A) { return E == A }) }, isAffected: function (D, E, F) { return ((F.element != E) && ((!F._containers) || this.isContained(E, F)) && ((!F.accept) || (Element.classNames(E).detect(function (A) { return F.accept.include(A) }))) && Position.within(F.element, D[0], D[1])) }, deactivate: function (B) { if (B.hoverclass) { Element.removeClassName(B.element, B.hoverclass) } this.last_active = null }, activate: function (B) { if (B.hoverclass) { Element.addClassName(B.element, B.hoverclass) } this.last_active = B }, show: function (E, G) { if (!this.drops.length) { return } var H, F = []; this.drops.each(function (A) { if (Droppables.isAffected(E, G, A)) { F.push(A) } }); if (F.length > 0) { H = Droppables.findDeepestChild(F) } if (this.last_active && this.last_active != H) { this.deactivate(this.last_active) } if (H) { Position.within(H.element, E[0], E[1]); if (H.onHover) { H.onHover(G, H.element, Position.overlap(H.overlap, H.element)) } if (H != this.last_active) { Droppables.activate(H) } } }, fire: function (D, C) { if (!this.last_active) { return } Position.prepare(); if (this.isAffected([Event.pointerX(D), Event.pointerY(D)], C, this.last_active)) { if (this.last_active.onDrop) { this.last_active.onDrop(C, this.last_active.element, D); return true } } }, reset: function () { if (this.last_active) { this.deactivate(this.last_active) } } }; var Draggables = { drags: [], observers: [], register: function (B) { if (this.drags.length == 0) { this.eventMouseUp = this.endDrag.bindAsEventListener(this); this.eventMouseMove = this.updateDrag.bindAsEventListener(this); this.eventKeypress = this.keyPress.bindAsEventListener(this); Event.observe(document, "mouseup", this.eventMouseUp); Event.observe(document, "mousemove", this.eventMouseMove); Event.observe(document, "keypress", this.eventKeypress) } this.drags.push(B) }, unregister: function (B) { this.drags = this.drags.reject(function (A) { return A == B }); if (this.drags.length == 0) { Event.stopObserving(document, "mouseup", this.eventMouseUp); Event.stopObserving(document, "mousemove", this.eventMouseMove); Event.stopObserving(document, "keypress", this.eventKeypress) } }, activate: function (B) { if (B.options.delay) { this._timeout = setTimeout(function () { Draggables._timeout = null; window.focus(); Draggables.activeDraggable = B }.bind(this), B.options.delay) } else { window.focus(); this.activeDraggable = B } }, deactivate: function () { this.activeDraggable = null }, updateDrag: function (C) { if (!this.activeDraggable) { return } var D = [Event.pointerX(C), Event.pointerY(C)]; if (this._lastPointer && (this._lastPointer.inspect() == D.inspect())) { Event.stop(C); return } this._lastPointer = D; this.activeDraggable.updateDrag(C, D) }, endDrag: function (B) { if (this._timeout) { clearTimeout(this._timeout); this._timeout = null } if (!this.activeDraggable) { return } this._lastPointer = null; this.activeDraggable.endDrag(B); this.activeDraggable = null }, keyPress: function (B) { if (this.activeDraggable) { this.activeDraggable.keyPress(B) } }, addObserver: function (B) { this.observers.push(B); this._cacheObserverCallbacks() }, removeObserver: function (B) { this.observers = this.observers.reject(function (A) { return A.element == B }); this._cacheObserverCallbacks() }, notify: function (F, D, E) { if (this[F + "Count"] > 0) { this.observers.each(function (A) { if (A[F]) { A[F](F, D, E) } }) } if (D.options[F]) { D.options[F](D, E) } }, _cacheObserverCallbacks: function () { ["onStart", "onEnd", "onDrag"].each(function (B) { Draggables[B + "Count"] = Draggables.observers.select(function (A) { return A[B] }).length }) } }; var Draggable = Class.create({ initialize: function (F) { var E = { handle: false, reverteffect: function (B, C, H) { var A = Math.sqrt(Math.abs(C ^ 2) + Math.abs(H ^ 2)) * 0.02; new Effect.Move(B, { x: -H, y: -C, duration: A, queue: { scope: "_draggable", position: "end" } }) }, endeffect: function (A) { var B = Object.isNumber(A._opacity) ? A._opacity : 1; new Effect.Opacity(A, { duration: 0.2, from: 0.7, to: B, queue: { scope: "_draggable", position: "end" }, afterFinish: function () { Draggable._dragging[A] = false } }) }, zindex: 1000, revert: false, quiet: false, scroll: false, scrollSensitivity: 20, scrollSpeed: 15, snap: false, delay: 0 }; if (!arguments[1] || Object.isUndefined(arguments[1].endeffect)) { Object.extend(E, { starteffect: function (A) { A._opacity = Element.getOpacity(A); Draggable._dragging[A] = true; new Effect.Opacity(A, { duration: 0.2, from: A._opacity, to: 0.7 }) } }) } var D = Object.extend(E, arguments[1] || {}); this.element = $(F); if (D.handle && Object.isString(D.handle)) { this.handle = this.element.down("." + D.handle, 0) } if (!this.handle) { this.handle = $(D.handle) } if (!this.handle) { this.handle = this.element } if (D.scroll && !D.scroll.scrollTo && !D.scroll.outerHTML) { D.scroll = $(D.scroll); this._isScrollChild = Element.childOf(this.element, D.scroll) } Element.makePositioned(this.element); this.options = D; this.dragging = false; this.eventMouseDown = this.initDrag.bindAsEventListener(this); Event.observe(this.handle, "mousedown", this.eventMouseDown); Draggables.register(this) }, destroy: function () { Event.stopObserving(this.handle, "mousedown", this.eventMouseDown); Draggables.unregister(this) }, currentDelta: function () { return ([parseInt(Element.getStyle(this.element, "left") || "0"), parseInt(Element.getStyle(this.element, "top") || "0")]) }, initDrag: function (E) { Draggables.notify("onBeforeStart", this, E); if (!Object.isUndefined(Draggable._dragging[this.element]) && Draggable._dragging[this.element]) { return } if (Event.isLeftClick(E)) { var G = Event.element(E); if ((tag_name = G.tagName.toUpperCase()) && (tag_name == "INPUT" || tag_name == "SELECT" || tag_name == "OPTION" || tag_name == "BUTTON" || tag_name == "TEXTAREA")) { return } var H = [Event.pointerX(E), Event.pointerY(E)]; var F = this.element.cumulativeOffset(); this.offset = [0, 1].map(function (A) { return (H[A] - F[A]) }); Draggables.activate(this); Event.stop(E) } }, startDrag: function (D) { this.dragging = true; if (!this.delta) { this.delta = this.currentDelta() } if (this.options.zindex) { this.originalZ = parseInt(Element.getStyle(this.element, "z-index") || 0); this.element.style.zIndex = this.options.zindex } if (this.options.ghosting) { this._clone = this.element.cloneNode(true); this._originallyAbsolute = (this.element.getStyle("position") == "absolute"); if (!this._originallyAbsolute) { Position.absolutize(this.element) } this.element.parentNode.insertBefore(this._clone, this.element) } if (this.options.scroll) { if (this.options.scroll == window) { var C = this._getWindowScroll(this.options.scroll); this.originalScrollLeft = C.left; this.originalScrollTop = C.top } else { this.originalScrollLeft = this.options.scroll.scrollLeft; this.originalScrollTop = this.options.scroll.scrollTop } } Draggables.notify("onStart", this, D); if (this.options.starteffect) { this.options.starteffect(this.element) } }, updateDrag: function (event, pointer) { if (!this.dragging) { this.startDrag(event) } if (!this.options.quiet) { Position.prepare(); Droppables.show(pointer, this.element) } Draggables.notify("onDrag", this, event); this.draw(pointer); if (this.options.change) { this.options.change(this) } if (this.options.scroll) { this.stopScrolling(); var p; if (this.options.scroll == window) { with (this._getWindowScroll(this.options.scroll)) { p = [left, top, left + width, top + height] } } else { p = Position.page(this.options.scroll); p[0] += this.options.scroll.scrollLeft + Position.deltaX; p[1] += this.options.scroll.scrollTop + Position.deltaY; p.push(p[0] + this.options.scroll.offsetWidth); p.push(p[1] + this.options.scroll.offsetHeight) } var speed = [0, 0]; if (pointer[0] < (p[0] + this.options.scrollSensitivity)) { speed[0] = pointer[0] - (p[0] + this.options.scrollSensitivity) } if (pointer[1] < (p[1] + this.options.scrollSensitivity)) { speed[1] = pointer[1] - (p[1] + this.options.scrollSensitivity) } if (pointer[0] > (p[2] - this.options.scrollSensitivity)) { speed[0] = pointer[0] - (p[2] - this.options.scrollSensitivity) } if (pointer[1] > (p[3] - this.options.scrollSensitivity)) { speed[1] = pointer[1] - (p[3] - this.options.scrollSensitivity) } this.startScrolling(speed) } if (Prototype.Browser.WebKit) { window.scrollBy(0, 0) } Event.stop(event) }, finishDrag: function (L, I) { this.dragging = false; if (this.options.quiet) { Position.prepare(); var J = [Event.pointerX(L), Event.pointerY(L)]; Droppables.show(J, this.element) } if (this.options.ghosting) { if (!this._originallyAbsolute) { Position.relativize(this.element) } delete this._originallyAbsolute; Element.remove(this._clone); this._clone = null } var H = false; if (I) { H = Droppables.fire(L, this.element); if (!H) { H = false } } if (H && this.options.onDropped) { this.options.onDropped(this.element) } Draggables.notify("onEnd", this, L); var G = this.options.revert; if (G && Object.isFunction(G)) { G = G(this.element) } var K = this.currentDelta(); if (G && this.options.reverteffect) { if (H == 0 || G != "failure") { this.options.reverteffect(this.element, K[1] - this.delta[1], K[0] - this.delta[0]) } } else { this.delta = K } if (this.options.zindex) { this.element.style.zIndex = this.originalZ } if (this.options.endeffect) { this.options.endeffect(this.element) } Draggables.deactivate(this); Droppables.reset() }, keyPress: function (B) { if (B.keyCode != Event.KEY_ESC) { return } this.finishDrag(B, false); Event.stop(B) }, endDrag: function (B) { if (!this.dragging) { return } this.stopScrolling(); this.finishDrag(B, true); Event.stop(B) }, draw: function (G) { var H = this.element.cumulativeOffset(); if (this.options.ghosting) { var K = Position.realOffset(this.element); H[0] += K[0] - Position.deltaX; H[1] += K[1] - Position.deltaY } var I = this.currentDelta(); H[0] -= I[0]; H[1] -= I[1]; if (this.options.scroll && (this.options.scroll != window && this._isScrollChild)) { H[0] -= this.options.scroll.scrollLeft - this.originalScrollLeft; H[1] -= this.options.scroll.scrollTop - this.originalScrollTop } var J = [0, 1].map(function (A) { return (G[A] - H[A] - this.offset[A]) }.bind(this)); if (this.options.snap) { if (Object.isFunction(this.options.snap)) { J = this.options.snap(J[0], J[1], this) } else { if (Object.isArray(this.options.snap)) { J = J.map(function (B, A) { return (B / this.options.snap[A]).round() * this.options.snap[A] }.bind(this)) } else { J = J.map(function (A) { return (A / this.options.snap).round() * this.options.snap }.bind(this)) } } } var L = this.element.style; if ((!this.options.constraint) || (this.options.constraint == "horizontal")) { L.left = J[0] + "px" } if ((!this.options.constraint) || (this.options.constraint == "vertical")) { L.top = J[1] + "px" } if (L.visibility == "hidden") { L.visibility = "" } }, stopScrolling: function () { if (this.scrollInterval) { clearInterval(this.scrollInterval); this.scrollInterval = null; Draggables._lastScrollPointer = null } }, startScrolling: function (B) { if (!(B[0] || B[1])) { return } this.scrollSpeed = [B[0] * this.options.scrollSpeed, B[1] * this.options.scrollSpeed]; this.lastScrolled = new Date(); this.scrollInterval = setInterval(this.scroll.bind(this), 10) }, scroll: function () { var current = new Date(); var delta = current - this.lastScrolled; this.lastScrolled = current; if (this.options.scroll == window) { with (this._getWindowScroll(this.options.scroll)) { if (this.scrollSpeed[0] || this.scrollSpeed[1]) { var d = delta / 1000; this.options.scroll.scrollTo(left + d * this.scrollSpeed[0], top + d * this.scrollSpeed[1]) } } } else { this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000; this.options.scroll.scrollTop += this.scrollSpeed[1] * delta / 1000 } Position.prepare(); Droppables.show(Draggables._lastPointer, this.element); Draggables.notify("onDrag", this); if (this._isScrollChild) { Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer); Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000; Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000; if (Draggables._lastScrollPointer[0] < 0) { Draggables._lastScrollPointer[0] = 0 } if (Draggables._lastScrollPointer[1] < 0) { Draggables._lastScrollPointer[1] = 0 } this.draw(Draggables._lastScrollPointer) } if (this.options.change) { this.options.change(this) } }, _getWindowScroll: function (w) { var T, L, W, H; with (w.document) { if (w.document.documentElement && documentElement.scrollTop) { T = documentElement.scrollTop; L = documentElement.scrollLeft } else { if (w.document.body) { T = body.scrollTop; L = body.scrollLeft } } if (w.innerWidth) { W = w.innerWidth; H = w.innerHeight } else { if (w.document.documentElement && documentElement.clientWidth) { W = documentElement.clientWidth; H = documentElement.clientHeight } else { W = body.offsetWidth; H = body.offsetHeight } } } return { top: T, left: L, width: W, height: H } } }); Draggable._dragging = {}; var SortableObserver = Class.create({ initialize: function (D, C) { this.element = $(D); this.observer = C; this.lastValue = Sortable.serialize(this.element) }, onStart: function () { this.lastValue = Sortable.serialize(this.element) }, onEnd: function () { Sortable.unmark(); if (this.lastValue != Sortable.serialize(this.element)) { this.observer(this.element) } } }); var Sortable = { SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/, sortables: {}, _findRootElement: function (B) { while (B.tagName.toUpperCase() != "BODY") { if (B.id && Sortable.sortables[B.id]) { return B } B = B.parentNode } }, options: function (B) { B = Sortable._findRootElement($(B)); if (!B) { return } return Sortable.sortables[B.id] }, destroy: function (C) { C = $(C); var D = Sortable.sortables[C.id]; if (D) { Draggables.removeObserver(D.element); D.droppables.each(function (A) { Droppables.remove(A) }); D.draggables.invoke("destroy"); delete Sortable.sortables[D.element.id] } }, create: function (I) { I = $(I); var J = Object.extend({ element: I, tag: "li", dropOnEmpty: false, tree: false, treeTag: "ul", overlap: "vertical", constraint: "vertical", containment: I, handle: false, only: false, delay: 0, hoverclass: null, ghosting: false, quiet: false, scroll: false, scrollSensitivity: 20, scrollSpeed: 15, format: this.SERIALIZE_RULE, elements: false, handles: false, onChange: Prototype.emptyFunction, onUpdate: Prototype.emptyFunction }, arguments[1] || {}); this.destroy(I); var F = { revert: true, quiet: J.quiet, scroll: J.scroll, scrollSpeed: J.scrollSpeed, scrollSensitivity: J.scrollSensitivity, delay: J.delay, ghosting: J.ghosting, constraint: J.constraint, handle: J.handle }; if (J.starteffect) { F.starteffect = J.starteffect } if (J.reverteffect) { F.reverteffect = J.reverteffect } else { if (J.ghosting) { F.reverteffect = function (A) { A.style.top = 0; A.style.left = 0 } } } if (J.endeffect) { F.endeffect = J.endeffect } if (J.zindex) { F.zindex = J.zindex } var H = { overlap: J.overlap, containment: J.containment, tree: J.tree, hoverclass: J.hoverclass, onHover: Sortable.onHover }; var G = { onHover: Sortable.onEmptyHover, overlap: J.overlap, containment: J.containment, hoverclass: J.hoverclass }; Element.cleanWhitespace(I); J.draggables = []; J.droppables = []; if (J.dropOnEmpty || J.tree) { Droppables.add(I, G); J.droppables.push(I) } (J.elements || this.findElements(I, J) || []).each(function (A, C) { var B = J.handles ? $(J.handles[C]) : (J.handle ? $(A).select("." + J.handle)[0] : A); J.draggables.push(new Draggable(A, Object.extend(F, { handle: B }))); Droppables.add(A, H); if (J.tree) { A.treeNode = I } J.droppables.push(A) }); if (J.tree) { (Sortable.findTreeElements(I, J) || []).each(function (A) { Droppables.add(A, G); A.treeNode = I; J.droppables.push(A) }) } this.sortables[I.identify()] = J; Draggables.addObserver(new SortableObserver(I, J.onUpdate)) }, findElements: function (D, C) { return Element.findChildren(D, C.only, C.tree ? true : false, C.tag) }, findTreeElements: function (D, C) { return Element.findChildren(D, C.only, C.tree ? true : false, C.treeTag) }, onHover: function (G, H, F) { if (Element.isParent(H, G)) { return } if (F > 0.33 && F < 0.66 && Sortable.options(H).tree) { return } else { if (F > 0.5) { Sortable.mark(H, "before"); if (H.previousSibling != G) { var J = G.parentNode; G.style.visibility = "hidden"; H.parentNode.insertBefore(G, H); if (H.parentNode != J) { Sortable.options(J).onChange(G) } Sortable.options(H.parentNode).onChange(G) } } else { Sortable.mark(H, "after"); var I = H.nextSibling || null; if (I != G) { var J = G.parentNode; G.style.visibility = "hidden"; H.parentNode.insertBefore(G, I); if (H.parentNode != J) { Sortable.options(J).onChange(G) } Sortable.options(H.parentNode).onChange(G) } } } }, onEmptyHover: function (R, P, O) { var N = R.parentNode; var M = Sortable.options(P); if (!Element.isParent(P, R)) { var Q; var K = Sortable.findElements(P, { tag: M.tag, only: M.only }); var L = null; if (K) { var J = Element.offsetSize(P, M.overlap) * (1 - O); for (Q = 0; Q < K.length; Q += 1) { if (J - Element.offsetSize(K[Q], M.overlap) >= 0) { J -= Element.offsetSize(K[Q], M.overlap) } else { if (J - (Element.offsetSize(K[Q], M.overlap) / 2) >= 0) { L = Q + 1 < K.length ? K[Q + 1] : null; break } else { L = K[Q]; break } } } } P.insertBefore(R, L); Sortable.options(N).onChange(R); M.onChange(R) } }, unmark: function () { if (Sortable._marker) { Sortable._marker.hide() } }, mark: function (H, E) { var F = Sortable.options(H.parentNode); if (F && !F.ghosting) { return } if (!Sortable._marker) { Sortable._marker = ($("dropmarker") || Element.extend(document.createElement("DIV"))).hide().addClassName("dropmarker").setStyle({ position: "absolute" }); document.getElementsByTagName("body").item(0).appendChild(Sortable._marker) } var G = H.cumulativeOffset(); Sortable._marker.setStyle({ left: G[0] + "px", top: G[1] + "px" }); if (E == "after") { if (F.overlap == "horizontal") { Sortable._marker.setStyle({ left: (G[0] + H.clientWidth) + "px" }) } else { Sortable._marker.setStyle({ top: (G[1] + H.clientHeight) + "px" }) } } Sortable._marker.show() }, _tree: function (K, N, J) { var L = Sortable.findElements(K, N) || []; for (var M = 0; M < L.length; ++M) { var H = L[M].id.match(N.format); if (!H) { continue } var I = { id: encodeURIComponent(H ? H[1] : null), element: K, parent: J, children: [], position: J.children.length, container: $(L[M]).down(N.treeTag) }; if (I.container) { this._tree(I.container, N, I) } J.children.push(I) } return J }, tree: function (F) { F = $(F); var G = this.options(F); var H = Object.extend({ tag: G.tag, treeTag: G.treeTag, only: G.only, name: F.id, format: G.format }, arguments[1] || {}); var E = { id: null, parent: null, children: [], container: F, position: 0 }; return Sortable._tree(F, H, E) }, _constructIndex: function (D) { var C = ""; do { if (D.id) { C = "[" + D.position + "]" + C } } while ((D = D.parent) != null); return C }, sequence: function (D) { D = $(D); var C = Object.extend(this.options(D), arguments[1] || {}); return $(this.findElements(D, C) || []).map(function (A) { return A.id.match(C.format) ? A.id.match(C.format)[1] : "" }) }, setSequence: function (H, G) { H = $(H); var E = Object.extend(this.options(H), arguments[2] || {}); var F = {}; this.findElements(H, E).each(function (A) { if (A.id.match(E.format)) { F[A.id.match(E.format)[1]] = [A, A.parentNode] } A.parentNode.removeChild(A) }); G.each(function (B) { var A = F[B]; if (A) { A[1].appendChild(A[0]); delete F[B] } }) }, serialize: function (E) { E = $(E); var F = Object.extend(Sortable.options(E), arguments[1] || {}); var D = encodeURIComponent((arguments[1] && arguments[1].name) ? arguments[1].name : E.id); if (F.tree) { return Sortable.tree(E, arguments[1]).children.map(function (A) { return [D + Sortable._constructIndex(A) + "[id]=" + encodeURIComponent(A.id)].concat(A.children.map(arguments.callee)) }).flatten().join("&") } else { return Sortable.sequence(E, arguments[1]).map(function (A) { return D + "[]=" + encodeURIComponent(A) }).join("&") } } }; Element.isParent = function (D, C) { if (!D.parentNode || D == C) { return false } if (D.parentNode == C) { return true } return Element.isParent(D.parentNode, C) }; Element.findChildren = function (H, J, F, I) { if (!H.hasChildNodes()) { return null } I = I.toUpperCase(); if (J) { J = [J].flatten() } var G = []; $A(H.childNodes).each(function (A) { if (A.tagName && A.tagName.toUpperCase() == I && (!J || (Element.classNames(A).detect(function (C) { return J.include(C) })))) { G.push(A) } if (F) { var B = Element.findChildren(A, J, F, I); if (B) { G.push(B) } } }); return (G.length > 0 ? G.flatten() : []) }; Element.offsetSize = function (C, D) { return C["offset" + ((D == "vertical" || D == "height") ? "Height" : "Width")] };